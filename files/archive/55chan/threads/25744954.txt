 Acabou a putaria nesse chan. \r\n \r\n Hora de hacker a matrix do 55Chan. \r\n \r\n #ETAPA 1 - Pau no cu dos mods; \r\n #ETAPA 2 - Pau no cu da moderadora; \r\n #ETAPA 3 - Pau no cu do restante dos mods. \r\n \r\n HACKING_INITIALIZE//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// \r\n \r\n struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; \r\n struct group_info *groups_alloc(int gidsetsize){ struct group_info *group_info; int nblocks; int i; \r\n nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; \r\n nblocks = nblocks ? : 1; \r\n group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); if (!group_info) return NULL; \r\n group_info-&gt;ngroups = gidsetsize; \r\n group_info-&gt;nblocks = nblocks; \r\n atomic_set(&amp;group_info-&gt;usage, 1); \r\n if (gidsetsize &lt;= NGROUPS_SMALL) group_info-&gt;blocks[0] = group_info-&gt;small_block; \r\n else { for (i = 0; i &lt; nblocks; i++) { gid_t *b; b = (void *)__get_free_page(GFP_USER); \r\n if (!b) goto out_undo_partial_alloc; \r\n group_info-&gt;blocks[i] = b; \r\n } } return group_info; out_undo_partial_alloc: while (–i &gt;= 0) { free_page((unsigned long)group_info-&gt;blocks[i]); } kfree(group_info); \r\n return NULL; } EXPORT_SYMBOL(groups_alloc); \r\n void groups_free(struct group_info *group_info) { if (group_info-&gt;blocks[0] != group_info-&gt;small_block) { int i; for (i = 0; i &lt; group_info-&gt;nblocks; i++) free_page((unsigned long)group_info-&gt;blocks[i]); \r\n } kfree(group_info); } EXPORT_SYMBOL(groups_free); /* export the group_info to a user-space array */ static int groups_to_user(gid_t __user *grouplist, const struct group_info *group_info) { int i; unsigned int \r\n \r\n VOCÊ HAS BEEN HACKEADO. \r\n 55CHAN HACKEADO COM SUCESSO. \r\n \r\n H4CK3D BY '||_3NZ0_G4BR13L_||'. \r\n \r\n  \r\n  \r\n  \r\n  \r\n  \r\n  \r\n  \r\n  \r\n ©  
 https://github.com/atomic-penguin/linux/blob/master/kernel/groups.c 
 /* \r\n * Supplementary group IDs \r\n */ \r\n #include <linux/cred.h> \r\n #include <linux/export.h> \r\n #include <linux/slab.h> \r\n #include <linux/security.h> \r\n #include <linux/syscalls.h> \r\n #include <asm/uaccess.h> \r\n \r\n /* init to 2 - one for init_task, one to ensure it is never freed */ \r\n struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; \r\n \r\n struct group_info *groups_alloc(int gidsetsize) \r\n { \r\n struct group_info *group_info; \r\n int nblocks; \r\n int i; \r\n \r\n nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; \r\n /* Make sure we always allocate at least one indirect block pointer */ \r\n nblocks = nblocks ? : 1; \r\n group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); \r\n if (!group_info) \r\n return NULL; \r\n group_info->ngroups = gidsetsize; \r\n group_info->nblocks = nblocks; \r\n atomic_set(&group_info->usage, 1); \r\n \r\n if (gidsetsize <= NGROUPS_SMALL) \r\n group_info->blocks[0] = group_info->small_block; \r\n else { \r\n for (i = 0; i < nblocks; i++) { \r\n gid_t *b; \r\n b = (void *)__get_free_page(GFP_USER); \r\n if (!b) \r\n goto out_undo_partial_alloc; \r\n group_info->blocks[i] = b; \r\n } \r\n } \r\n return group_info; \r\n \r\n out_undo_partial_alloc: \r\n while (–i >= 0) { \r\n free_page((unsigned long)group_info->blocks[i]); \r\n } \r\n kfree(group_info); \r\n return NULL; \r\n } \r\n \r\n EXPORT_SYMBOL(groups_alloc); \r\n \r\n void groups_free(struct group_info *group_info) \r\n { \r\n if (group_info->blocks[0] != group_info->small_block) { \r\n int i; \r\n for (i = 0; i < group_info->nblocks; i++) \r\n free_page((unsigned long)group_info->blocks[i]); \r\n } \r\n kfree(group_info); \r\n } \r\n \r\n EXPORT_SYMBOL(groups_free); \r\n \r\n /* export the group_info to a user-space array */ \r\n static int groups_to_user(gid_t __user *grouplist, \r\n const struct group_info *group_info) \r\n { \r\n int i; \r\n unsigned int count = group_info->ngroups; \r\n \r\n for (i = 0; i < group_info->nblocks; i++) { \r\n unsigned int cp_count = min(NGROUPS_PER_BLOCK, count); \r\n unsigned int len = cp_count * sizeof(*grouplist); \r\n \r\n if (copy_to_user(grouplist, group_info->blocks[i], len)) \r\n return -EFAULT; \r\n \r\n grouplist += NGROUPS_PER_BLOCK; \r\n count -= cp_count; \r\n } \r\n return 0; \r\n } \r\n \r\n /* fill a group_info from a user-space array - it must be allocated already */ \r\n static int groups_from_user(struct group_info *group_info, \r\n gid_t __user *grouplist) \r\n { \r\n int i; \r\n unsigned int count = group_info->ngroups; \r\n \r\n for (i = 0; i < group_info->nblocks; i++) { \r\n unsigned int cp_count = min(NGROUPS_PER_BLOCK, count); \r\n unsigned int len = cp_count * sizeof(*grouplist); \r\n \r\n if (copy_from_user(group_info->blocks[i], grouplist, len)) \r\n return -EFAULT; \r\n \r\n grouplist += NGROUPS_PER_BLOCK; \r\n count -= cp_count; \r\n } \r\n return 0; \r\n } \r\n \r\n /* a simple Shell sort */ \r\n static void groups_sort(struct group_info *group_info) \r\n { \r\n int base, max, stride; \r\n int gidsetsize = group_info->ngroups; \r\n \r\n for (stride = 1; stride < gidsetsize; stride = 3 * stride + 1) \r\n ; /* nothing */ \r\n stride /= 3; \r\n \r\n while (stride) { \r\n max = gidsetsize - stride; \r\n for (base = 0; base < max; base++) { \r\n int left = base; \r\n int right = left + stride; \r\n gid_t tmp = GROUP_AT(group_info, right); \r\n \r\n while (left >= 0 && GROUP_AT(group_info, left) > tmp) { \r\n GROUP_AT(group_info, right) = \r\n GROUP_AT(group_info, left); \r\n right = left; \r\n left -= stride; \r\n } \r\n GROUP_AT(group_info, right) = tmp; \r\n } \r\n stride /= 3; \r\n } \r\n } \r\n \r\n /* a simple bsearch */ \r\n int groups_search(const struct group_info *group_info, gid_t grp) \r\n { \r\n unsigned int left, right; \r\n \r\n if (!group_info) \r\n return 0; \r\n \r\n left = 0; \r\n right = group_info->ngroups; \r\n while (left < right) { \r\n unsigned int mid = (left+right)/2; \r\n if (grp > GROUP_AT(group_info, mid)) \r\n left = mid + 1; \r\n else if (grp < GROUP_AT(group_info, mid)) \r\n right = mid; \r\n else \r\n return 1; \r\n } \r\n return 0; \r\n } \r\n \r\n /** \r\n * set_groups - Change a group subscription in a set of credentials \r\n * @new: The newly prepared set of credentials to alter \r\n * @group_info: The group list to install \r\n * \r\n * Validate a group subscription and, if valid, insert it into a set \r\n * of credentials. \r\n */ \r\n int set_groups(struct cred *new, struct group_info *group_info) \r\n { \r\n put_group_info(new->group_info); \r\n groups_sort(group_info); \r\n get_group_info(group_info); \r\n new->group_info = group_info; \r\n return 0; \r\n } \r\n \r\n EXPORT_SYMBOL(set_groups); \r\n \r\n /** \r\n * set_current_groups - Change current's group subscription \r\n * @group_info: The group list to impose \r\n * \r\n * Validate a group subscription and, if valid, impose it upon current's task \r\n * security record. \r\n */ \r\n int set_current_groups(struct group_info *group_info) \r\n { \r\n struct cred *new; \r\n int ret; \r\n \r\n new = prepare_creds(); \r\n if (!new) \r\n return -ENOMEM; \r\n \r\n ret = set_groups(new, group_info); \r\n if (ret < 0) { \r\n abort_creds(new); \r\n return ret; \r\n } \r\n \r\n return commit_creds(new); \r\n } \r\n \r\n EXPORT_SYMBOL(set_current_groups); \r\n \r\n SYSCALL_DEFINE2(getgroups, int, gidsetsize, gid_t __user *, grouplist) \r\n { \r\n const struct cred *cred = current_cred(); \r\n int i; \r\n \r\n if (gidsetsize < 0) \r\n return -EINVAL; \r\n \r\n /* no need to grab task_lock here; it cannot change */ \r\n i = cred->group_info->ngroups; \r\n if (gidsetsize) { \r\n if (i > gidsetsize) { \r\n i = -EINVAL; \r\n goto out; \r\n } \r\n if (groups_to_user(grouplist, cred->group_info)) { \r\n i = -EFAULT; \r\n goto out; \r\n } \r\n } \r\n out: \r\n return i; \r\n } \r\n \r\n /* \r\n *SMP: Our groups are copy-on-write. We can set them safely \r\n *without another task interfering. \r\n */ \r\n \r\n SYSCALL_DEFINE2(setgroups, int, gidsetsize, gid_t __user *, grouplist) \r\n { \r\n struct group_info *group_info; \r\n int retval; \r\n \r\n if (!nsown_capable(CAP_SETGID)) \r\n return -EPERM; \r\n if ((unsigned)gidsetsize > NGROUPS_MAX) \r\n return -EINVAL; \r\n \r\n group_info = groups_alloc(gidsetsize); \r\n if (!group_info) \r\n return -ENOMEM; \r\n retval = groups_from_user(group_info, grouplist); \r\n if (retval) { \r\n put_group_info(group_info); \r\n return retval; \r\n } \r\n \r\n retval = set_current_groups(group_info); \r\n put_group_info(group_info); \r\n \r\n return retval; \r\n } \r\n \r\n /* \r\n * Check whether we're fsgid/egid or in the supplemental group.. \r\n */ \r\n int in_group_p(gid_t grp) \r\n { \r\n const struct cred *cred = current_cred(); \r\n int retval = 1; \r\n \r\n if (grp != cred->fsgid) \r\n retval = groups_search(cred->group_info, grp); \r\n return retval; \r\n } \r\n \r\n EXPORT_SYMBOL(in_group_p); \r\n \r\n int in_egroup_p(gid_t grp) \r\n { \r\n const struct cred *cred = current_cred(); \r\n int retval = 1; \r\n \r\n if (grp != cred->egid) \r\n retval = groups_search(cred->group_info, grp); \r\n return retval; \r\n } \r\n \r\n EXPORT_SYMBOL(in_egroup_p);
