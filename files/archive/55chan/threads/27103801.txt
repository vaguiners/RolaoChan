 O quanto Programação Orientada a Objetos é necessário?
 7.
 100% necessário, falando de POO mesmo e não de 'aprender java'.
 Necessário não é, já trabalhei em vários empregos com programação estruturada. \r\n \r\n Mas orientação a objetos é bem fácil, e tem que ser muito folgado/burro para não entender.
 Depende da linguagem, anão. Eu trabalho com Javascript e eu nem lembro quando foi a última vez que trabalhei com heranças, interfaces, sobrescrita de métodos e os padrões de projeto mais conhecidos. Uso no dia-a-dia os conceitos que aprendi com programação funcional e não poderia estar mais feliz.
 >>27103891 \r\n Pretendo iniciar com: HTML, CSS e JavaScript. \r\n Meu objetivo, pelo menos por enquanto, é Front end.
 >>27103921 \r\n Não querendo te desempolgar, anão, mas programação funcional eu, particularmente, acho mais complicado de se aprender do que a orientada a objetos. Com Javascript realmente é difícil as pessoas ficarem se apegando à POO, a não ser que você esteja trabalhando com Angular e use Typescript. Eu trabalho no meu dia-a-dia com React e uso o incrível número de zero classes.
 >>27103984 \r\n Entendo seu ponto. Acha que devo continuar seguindo a linha cronológica do curso ou estude POO e aprenda Python?
 >>27103984 \r\n Dá pra fazer joguinhos em programação funcional? Como eu representaria um personagem e um loop de jogo em programação funcional?
 >>27104071 \r\n O 'loop' é baseado em uma função onde, dado o estado do jogo, você tem o cenário daquilo. No caso de um jogo, a saída pode não ser determinística, mas a função sempre retorna algo parecido para uma mesma entrada. \r\n Por exemplo, caso você tenha um jogo de Snake, o famoso jogo da cobrinha, você tem uma função F com parâmetros (que são estados do jogo): \r\n 1. posição_da_cobra, uma tupla (x,y), de onde está a cabeça da cobra. \r\n 2. vetor_cobra, uma tupla (x,y) com o vetor de para onde a cobra está indo, podendo ser (0,1), (0,-1), (1,0), (-1,0). \r\n 3. entrada: a última tecla apertada, como input. \r\n 4. tempo: quanto tempo do jogo se passou. \r\n E, para essa entrada, a sua função F faz: \r\n (if (eq entrada seta_sonserina) (F mesmos parâmetros com o vetor de posição trocado)) \r\n (if (eq entrada seta_Grifinoria) (F mesmos parâmetros com o vetor de posição trocado)) \r\n Assim por diante, chamando a própria função de maneira recursiva, alterando o estado da próxima 'rodada'. \r\n O segredo acaba sendo discretizar o tempo. Faz sentido pra você?
 >>27104249 \r\n Como assim discretizar o tempo?
 >>27104320 \r\n Excelente pergunta, anão. Você deve ser um cara muito bonito e simpático. \r\n Discretizar o tempo significa não ter a noção de continuidade que teríamos caso estivéssemos programando em OpenGL, por exemplo. \r\n O tempo entre 1 segundo e 10 segundos deixa de ser 'infinito', limitado pelo processamento da máquina e seu clock, e passa a ser [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]. \r\n Para colocar mais frames do que 1 por segundo, o tempo se torna [0.5, 1, 1.5…]. E tudo isso acaba sendo entrada para sua função.
 >>27104249 \r\n Essa abordagem não me parece fazer sentido. \r\n \r\n O que são os 'objetos'? No final não fica parecido com programação imperativa?
 >>27104397 \r\n Não fica! Não deve ter ficado claro, mas a abordagem por estados segue a mesma abordagem da vida real, das leis que regem a nossa Matrix. \r\n Em um jogo de Snake, você tem a posição da cobra, o lugar para onde ela está indo, o quanto ela já comeu… Essas coisas são estados, e você programa com base nisso: 'qual transição deve ocorrer quando o estado deixa de ser X e passa a ser Y?'. \r\n - Pra qual lado a cobra vai quando a entrada for SETA_sonserina? \r\n - Qual a nova posição da cobra se ela estava indo para a sonserina e estava na posição (1,1)? \r\n A função sempre retorna o mesmo valor para aquele conjunto de estados. Você trabalha com a abstração da vida real.
 >>27104460 \r\n Pelo que eu entendi, em programação funcional eu faria move_objeto(cobrinha), ao invés de cobrainha.move() da programação orientada a objetos. Qual é a diferença, neste caso, de programação funcional para programação imperativa?
 >>27104502 \r\n A função move_objeto não altera variável alguma, ela altera os seus próprios parâmetros. \r\n É como se você tivesse: \r\n move_objecto(x, y, x_direcao, y_direcao), que retorna move_objecto(x+x_direcao, y+y_direcao, x_direcao, y_direcao).
 >>27104745 \r\n Pior ainda, é o mesmo que fazer move_objeto(&x,&y,&vx,&vy). O código fonte do Quake original é cheio de porcarias assim porque foi feito todo em C e assembly.
