 Existe uma tecnologia chamada SIMD: Single Instruction Multiple Data. Basicamente, um processador consegue processar mais de um valor ao mesmo tempo com um nucleo. No caso dos processadores de computadores pessoais, temos o AVX, que processa 256 bit de dados ao mesmo tempo, ou 8 números de ponto flutuante de 32 bits. Se seu processador tem 6 nucleos e AVX, você pode processar 48 números de ponto flutuante ao mesmo tempo. Isso é fornicação pra caralho, mas ninguém, ABSOLUTAMENTE NINGUÉM, comenta sobre essa tecnologia. Isso simplesmente torna a tua CPU em uma GPU bosta, mas capaz de acelerar tarefas simples. Por que ninguém comenta sobre essas tecnologias?
 Apenas o melhor parênquima paliçádico do dia. Forte abraço ao grande Daniel.
 >>26950039 \r\n Bump.
 Que comentários você estava esperando? Isso é algo que deveria ser transparente. Um programa já compilado para utilizar isso. \r\n \r\n A única vez que vi alguém reclamando foi quando usei o Tensorflow e ele dava um 'warning' dizendo que o processador tinha AVX, mas a distribuição não estava usando.
 Porque não faz diferença na vida de ninguém saber disso. Já ouviu falar de delegação e abstração? Significa 'não quero saber como faz, só faz e pronto'. Se você for um engenheiro da computação ou eletricista focado em eletrônica, até faz diferença na sua vida, talvez pra um técnico de consertos de computador. Mas em geral saber disso não faz diferença nenhuma na vida da grande maioria das pessoas. \r\n \r\n Also, \r\n >uma thread morreu pra dar lugar a essa bosta 
 >>26950039 \r\n >ponto flutuante \r\n >não dizendo vírgula \r\n Vira-lata.
 >>26950068 \r\n Compiladores atualmente conseguem automatizar SIMD em tarefas e loops simples. Além disso, o GCC e Clang consegue utilizar a Intel Instrinsics, que é a forma explícita do SIMD para o AVX e SSE. \r\n \r\n >>26950072 \r\n Não estou falando de pessoas comuns, estou falando de programadores, professores. Eu nunca ouvi sobre essa tecnologia nos meus 10 anos de programação e isso simplesmente resolveu a minha vida como programador para acelerar projetos. Não duvido que muitos programas poderiam ter sido acelerados com isso, inclusive jogos, mas para dar lugar ao conforto de programar em C#, Javascript, Python, e outras linguagens de garotosoja, removeram completamente a capacidade de poder utilizar uma tecnologia fornicação e termos programas mais rápidos.
 >>26950140 \r\n >Não estou falando de pessoas comuns, estou falando de programadores, professores. \r\n E por que você está postando isso no b ao invés do comp?
 >>26950166 \r\n Lugar mais parado que só a porra. Also, se pessoas comuns souberem mais sobre essa tecnologia, talvez essa tecnologia seja mais utilizada, para atender melhor as necessidades dos clientes.
 >>26950140 \r\n >Compiladores atualmente conseguem automatizar SIMD em tarefas e loops simples \r\n \r\n Sim, continua no caso de que você compila utilizando as suas flags e eu uso o seu binário aproveitando do que estiver disponível no meu computador. \r\n \r\n >Não estou falando de pessoas comuns, estou falando de programadores, professores \r\n \r\n Acontece que a maioria das tarefas dos programadores são programas CRUDS. Em que o maior 'overhead' está em pegar alguma coisa da memória secundária ou internet. O que você conseguiu otimizar deve ser algo bem específico que utiliza bastante de processamento em arrays.
 Não entendo nada, está tudo em computadorês.
 >>26950140 \r\n >Não duvido que muitos programas poderiam ter sido acelerados com isso, inclusive jogos, mas para dar lugar ao conforto de programar em C#, Javascript, Python, e outras linguagens de garotosoja, removeram completamente a capacidade de poder utilizar uma tecnologia fornicação e termos programas mais rápidos. \r\n O que te garante que essas tecnologias de sojagaroto já não usam isso? E se não usam, por que acha que não podem vir a usar em um futuro próximo? Todas elas são baseadas em C ou C++ (que é baseado em C).
 >>26950172 \r\n >se pessoas comuns souberem mais sobre essa tecnologia \r\n Que diferença faz pra pessoas comuns? Pro povo e maior parte dos empresários pouco interessa se você está usando AVX ou melhorando o algoritmo, o que interessa é se o programa está mais rápido ou não. Pouco importa COMO você fez isso. As pessoas querem uma abstração, não querem saber da implementação.
 >8 números de ponto flutuante de 32 bits \r\n \r\n Tente explanar isso para um leigo, vamos ver se você tem brio.
 >>26950192 \r\n Linguagens interpretadas como Python, duvido bastante, mas Java já vi. Possivelmente, o C# também tem. Mas nem em Java eu cheguei a achar muitos artigos e tutoriais sobre. \r\n \r\n >>26950212 \r\n Exato, filho da puta! Com AVX, poderemos processar arrays e grandes conjuntos de dados mais rapidamente, possivelmente acelerando o programa em geral. \r\n \r\n >>26950181 \r\n Eu prefiro usar intrinsics ou assembly mesmo. Trabalhar dependendo muito do compilador é uma merda. No meu caso, consegui acelerar uma simulação de n-body. Rodou lindamente com mais de 10k objetos em CPU. \r\n \r\n >>26950225 \r\n E o que precisa explicar? Números de ponto flutuantes são números reais, essencialmente.
 Explique em poucas palavras para uma criança o que você acabou de dizer.
 >>26950272 \r\n O seu joguinho de viado poderia ser mais rápido se os programadores soubesse aproveitar melhor os recursos do seu processador.
 >>26950268 \r\n >E o que precisa explicar? Números de ponto flutuantes são números reais, essencialmente. \r\n Todos os números não são reais? \r\n Anão, você não tem didática nenhuma.
 >>26950291 \r\n >soubessem \r\n Fix'd.
 >>26950268 \r\n >E o que precisa explicar? Números de ponto flutuantes são números reais, essencialmente. \r\n \r\n Vá dar o cu.
 >>26950268 \r\n >essencialmente 
 >>26950291 \r\n Mas os programadores já não sabem disso? Vide os consoles da geração passada executado joguinhos pesados. Um PlayStation 3 tem 256 megabytes de memória RAM e um processador antigo, e executa Grand Theft Auto 5 com maestria.
